package postgres

import (
    "context"
    "embed"
    "errors"

    "{{ .Module }}/internal/pkg/configs"
    "github.com/golang-migrate/migrate/v4"
    _ "github.com/golang-migrate/migrate/v4/database/postgres"

    "github.com/golang-migrate/migrate/v4/source/iofs"
    "github.com/jmoiron/sqlx"
)

//go:embed migrations/*.sql
var MigrationsFS embed.FS


type Config struct {
    URI                string `env:"DATABASE_URI" toml:"uri"`
    MaxOpenConnections int    `env:"DATABASE_MAX_OPEN_CONNECTIONS" env-default:"50"  toml:"max_open_connections"`
    MaxIDLEConnections int    `env:"DATABASE_MAX_IDLE_CONNECTIONS" env-default:"10"  toml:"max_idle_connections"`
}

func NewDatabase(config *Config) (*sqlx.DB, error) {
    database, err := sqlx.Connect("postgres", config.URI)
    if err != nil {
        return nil, err
    }
    database.SetMaxOpenConns(config.MaxOpenConnections)
    database.SetMaxIdleConns(config.MaxIDLEConnections)
    return database, nil
}

type MigrateManager struct {
    database *sqlx.DB
    config   *Config
}

func NewMigrateManager(database *sqlx.DB, config *Config) *MigrateManager {
    return &MigrateManager{
        database: database,
        config:   config,
    }
}

func (m MigrateManager) Up(_ context.Context) error {
    source, err := iofs.New(MigrationsFS, "migrations")
    if err != nil {
        return err
    }
    instance, err := migrate.NewWithSourceInstance("iofs", source, m.config.URI)
    if err != nil {
        return err
    }
    if err := instance.Up(); err != nil {
        if errors.Is(err, migrate.ErrNoChange) {
            return nil
        }
        return err
    }
    return nil
}
