package repositories

import (
    "context"
{{- range $value := .Params }}
    {{- if .IsSlice }}
    "github.com/lib/pq"
        {{- break }}
    {{- end }}
{{- end }}
    "database/sql"
    "errors"
    "testing"

    "{{ .Module }}/internal/pkg/errs"
    "{{ .Module }}/internal/pkg/postgres"
    "github.com/DATA-DOG/go-sqlmock"
    "go.uber.org/mock/gomock"
    "github.com/jaswdr/faker"
    "github.com/stretchr/testify/assert"

    "{{ .Module }}/internal/app/{{ .AppName }}/entities/{{ .DirName }}"
    "{{ .Module }}/internal/pkg/pointer"
    "{{ .Module }}/internal/pkg/uuid"
    "github.com/jmoiron/sqlx"
)

func TestNew{{ .RepositoryTypeName }}(t *testing.T) {
    mockDB, _, err := postgres.NewMockPostgreSQL(t)
    if err != nil {
        t.Fatal(err)
        return
    }
    defer mockDB.Close()
    type args struct {
        writeDB database
        readDB database
        logger   logger
    }
    tests := []struct {
        name  string
        setup func()
        args  args
        want  *{{ .RepositoryTypeName }}
    }{
        {
            name:  "ok",
            setup: func() {},
            args: args{
                writeDB: mockDB,
                readDB: mockDB,
            },
            want: &{{ .RepositoryTypeName }}{
                writeDB: mockDB,
                readDB: mockDB,
            },
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            got := New{{ .RepositoryTypeName }}(tt.args.readDB, tt.args.writeDB, tt.args.logger)
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test{{ .RepositoryTypeName }}_Create(t *testing.T) {
    mockDB, mock, err := postgres.NewMockPostgreSQL(t)
    if err != nil {
        t.Fatal(err)
        return
    }
    defer mockDB.Close()
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mockLogger := NewMocklogger(ctrl)
    query := "INSERT INTO public.{{ .TableName }} (id,created_at,updated_at,{{- range $i, $value := .Params }}{{if $i}},{{end}}{{ $value.Tag }}{{- end }}) VALUES ($1,$2,$3,{{ range $i, $value := .Params }}{{if $i}},{{end}}${{ add $i 4}}{{- end }})"
    {{ .Variable }} := entities.NewMock{{ .EntityName }}(t)
    ctx := context.Background()
    type fields struct {
        writeDB database
        readDB database
        logger   logger
    }
    type args struct {
        ctx  context.Context
        {{ .Variable }} entities.{{ .EntityName }}
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mock.ExpectExec(query).
                    WithArgs(
                        {{ $.Variable }}.ID,
                        {{ $.Variable }}.UpdatedAt,
                        {{ $.Variable }}.CreatedAt,
{{- range $value := .Params }}
    {{- if $value.IsSlice }}
                        pq.Array({{ $.Variable }}.{{ $value.GetName }}),
    {{- else }}
                        {{ $.Variable }}.{{ $value.GetName }},
    {{- end }}
{{- end }}
                    ).
                     					WillReturnResult(sqlmock.NewResult(0, 1))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx:  ctx,
                {{ .Variable }}: {{ .Variable }},
            },
            wantErr: nil,
        },
        {
            name: "database error",
            setup: func() {
                mock.ExpectExec(query).
                    WithArgs(
                        {{ $.Variable }}.ID,
                        {{ $.Variable }}.UpdatedAt,
                        {{ $.Variable }}.CreatedAt,
{{- range $value := .Params }}
    {{- if $value.IsSlice }}
                        pq.Array({{ $.Variable }}.{{ $value.GetName }}),
    {{- else }}
                        {{ $.Variable }}.{{ $value.GetName }},
    {{- end }}
{{- end }}
                    ).
                    WillReturnError(errors.New("test error"))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx:  ctx,
                {{ .Variable }}: {{ .Variable }},
            },
            wantErr: errs.FromPostgresError(errors.New("test error")),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            r := &{{ .RepositoryTypeName }}{
                writeDB: tt.fields.writeDB,
                readDB: tt.fields.readDB,
                logger:   tt.fields.logger,
            }
            err := r.Create(tt.args.ctx, tt.args.{{ .Variable }})
            assert.ErrorIs(t, err, tt.wantErr)
        })
    }
}

func Test{{ .RepositoryTypeName }}_Get(t *testing.T) {
    mockDB, mock, err := postgres.NewMockPostgreSQL(t)
    if err != nil {
        t.Fatal(err)
        return
    }
    defer mockDB.Close()
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mockLogger := NewMocklogger(ctrl)
    query := "SELECT {{ .TableName }}.id, {{ .TableName }}.created_at, {{ .TableName }}.updated_at{{ range $key, $value := .Params }}, {{ $.TableName }}.{{ $value.Tag }}{{ end }} FROM public.{{ .TableName }} WHERE id = $1 LIMIT 1"
    {{ .Variable }} := entities.NewMock{{ .EntityName }}(t)
    ctx := context.Background()
    type fields struct {
        writeDB database
        readDB database
        logger   logger
    }
    type args struct {
        ctx context.Context
        id  uuid.UUID
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    entities.{{ .EntityName }}
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                rows := new{{ .EntityName }}Rows(t, []entities.{{ .EntityName }}{ {{- .Variable -}} })
                mock.ExpectQuery(query).WithArgs({{ .Variable }}.ID).WillReturnRows(rows)
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                id:  {{ .Variable }}.ID,
            },
            want:    {{ .Variable }},
            wantErr: nil,
        },
        {
            name: "unexpected behavior",
            setup: func() {
                mock.ExpectQuery(query).WithArgs({{ .Variable }}.ID).WillReturnError(errors.New("test error"))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx: context.Background(),
                id:  {{ .Variable }}.ID,
            },
            want:  entities.{{ .EntityName }}{},
            wantErr: errs.FromPostgresError(errors.New("test error")).
                WithParam("{{ .KeyName }}_id", {{ .Variable }}.ID.String()),
        },
        {
            name: "not found",
            setup: func() {
                mock.ExpectQuery(query).WithArgs({{ .Variable }}.ID).WillReturnError(sql.ErrNoRows)
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx: context.Background(),
                id:  {{ .Variable }}.ID,
            },
            want:  entities.{{ .EntityName }}{},
            wantErr: errs.NewEntityNotFoundError().WithParam("{{ .KeyName }}_id", {{ .Variable }}.ID.String()),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            r := &{{ .RepositoryTypeName }}{
                writeDB: tt.fields.writeDB,
                readDB: tt.fields.readDB,
                logger:   tt.fields.logger,
            }
            got, err := r.Get(tt.args.ctx, tt.args.id)
            assert.ErrorIs(t, err, tt.wantErr)
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test{{ .RepositoryTypeName }}_List(t *testing.T) {
    mockDB, mock, err := postgres.NewMockPostgreSQL(t)
    if err != nil {
        t.Fatal(err)
        return
    }
    defer mockDB.Close()
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mockLogger := NewMocklogger(ctrl)
    ctx := context.Background()
    var {{ .ListVariable }} []entities.{{ .EntityName }}
    for i := 0; i < faker.New().IntBetween(2, 20); i++ {
        {{ .ListVariable }} = append({{ .ListVariable }}, entities.NewMock{{ .EntityName }}(t))
    }
    filter := entities.{{ .FilterTypeName }}{
		PageSize:   pointer.Of(uint64(10)),
		PageNumber: pointer.Of(uint64(2)),
		Search:     nil,
		OrderBy:    []string{"id ASC"},
	}
    query := "SELECT {{ .TableName }}.id, {{ .TableName }}.created_at, {{ .TableName }}.updated_at{{ range $key, $value := .Params }}, {{ $.TableName }}.{{ $value.Tag }}{{ end }} FROM public.{{ .TableName }} ORDER BY id ASC LIMIT 10 OFFSET 10"
    type fields struct {
        writeDB database
        readDB database
        logger   logger
    }
    type args struct {
        ctx    context.Context
        filter entities.{{ .FilterTypeName }}
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    []entities.{{ .EntityName }}
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mock.ExpectQuery(query).
                    WillReturnRows(new{{ .EntityName }}Rows(t, {{ .ListVariable }}))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx:    ctx,
                filter: filter,
            },
            want:    {{ .ListVariable }},
            wantErr: nil,
        },
        {
            name: "unexpected behavior",
            setup: func() {
                mock.ExpectQuery(query).WillReturnError(errors.New("test error"))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx:    ctx,
                filter: filter,
            },
            want: nil,
            wantErr: &errs.Error{
                Code:    13,
                Message: "Unexpected behavior.",
                Params: errs.Params{ {Key: "error", Value: "test error"} },
            },
        },
        {
            name: "database error",
            setup: func() {
                mock.ExpectQuery(query).
                    WillReturnError(errors.New("test error"))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx:    ctx,
                filter: filter,
            },
            want:    nil,
            wantErr: errs.FromPostgresError(errors.New("test error")),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            r := &{{ .RepositoryTypeName }}{
                writeDB: tt.fields.writeDB,
                readDB: tt.fields.readDB,
                logger:   tt.fields.logger,
            }
            got, err := r.List(tt.args.ctx, tt.args.filter)
            assert.ErrorIs(t, err, tt.wantErr)
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test{{ .RepositoryTypeName }}_Update(t *testing.T) {
    mockDB, mock, err := postgres.NewMockPostgreSQL(t)
    if err != nil {
        t.Fatal(err)
        return
    }
    defer mockDB.Close()
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mockLogger := NewMocklogger(ctrl)
    {{ .Variable }} := entities.NewMock{{ .EntityName }}(t)
    query := `UPDATE public.{{ .TableName }} SET created_at = $1, updated_at = $2, {{ range $i, $value := .Params }}{{if $i}}, {{end}}{{ $value.Tag }} = ${{ add $i 3}}{{- end }} WHERE id = ${{ add (len $.Params) 3 }}`
    ctx := context.Background()
    type fields struct {
        writeDB database
        readDB database
        logger   logger
    }
    type args struct {
        ctx  context.Context
        {{ .Variable }} entities.{{ .EntityName }}
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mock.ExpectExec(query).
                    WithArgs(
                        {{ $.Variable }}.CreatedAt,
                        {{ $.Variable }}.UpdatedAt,
{{- range $value := .Params }}
    {{- if $value.IsSlice }}
                        pq.Array({{ $.Variable }}.{{ $value.GetName }}),
    {{- else }}
                        {{ $.Variable }}.{{ $value.GetName }},
    {{- end }}
{{- end }}
                        {{ $.Variable }}.ID,
                    ).
                    WillReturnResult(sqlmock.NewResult(0, 1))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx:  ctx,
                {{ .Variable }}: {{ .Variable }},
            },
            wantErr: nil,
        },
        {
            name: "not found",
            setup: func() {
                mock.ExpectExec(query).
                    WithArgs(
                        {{ $.Variable }}.CreatedAt,
                        {{ $.Variable }}.UpdatedAt,
{{- range $value := .Params }}
    {{- if $value.IsSlice }}
                        pq.Array({{ $.Variable }}.{{ $value.GetName }}),
    {{- else }}
                        {{ $.Variable }}.{{ $value.GetName }},
    {{- end }}
{{- end }}
                        {{ $.Variable }}.ID,
                    ).
                    WillReturnResult(sqlmock.NewResult(0, 0))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx:  ctx,
                {{ .Variable }}: {{ .Variable }},
            },
            wantErr: errs.NewEntityNotFoundError().WithParam("{{ .KeyName }}_id", {{ .Variable }}.ID.String()),
        },
        {
            name: "database error",
            setup: func() {
                mock.ExpectExec(query).
                    WithArgs(
                        {{ $.Variable }}.CreatedAt,
                        {{ $.Variable }}.UpdatedAt,
{{- range $value := .Params }}
    {{- if $value.IsSlice }}
                        pq.Array({{ $.Variable }}.{{ $value.GetName }}),
    {{- else }}
                        {{ $.Variable }}.{{ $value.GetName }},
    {{- end }}
{{- end }}
                        {{ $.Variable }}.ID,
                    ).
                    WillReturnError(errors.New("test error"))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx:  ctx,
                {{ .Variable }}: {{ .Variable }},
            },
            wantErr: errs.FromPostgresError(errors.New("test error")).WithParam("{{ .KeyName }}_id", {{ .Variable }}.ID.String()),
        },
        {
            name: "unexpected error",
            setup: func() {
                mock.ExpectExec(query).
                    WithArgs(
                        {{ $.Variable }}.CreatedAt,
                        {{ $.Variable }}.UpdatedAt,
{{- range $value := .Params }}
    {{- if $value.IsSlice }}
                        pq.Array({{ $.Variable }}.{{ $value.GetName }}),
    {{- else }}
                        {{ $.Variable }}.{{ $value.GetName }},
    {{- end }}
{{- end }}
                        {{ $.Variable }}.ID,
                    ).
                    WillReturnError(errors.New("test error"))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx:  ctx,
                {{ .Variable }}: {{ .Variable }},
            },
            wantErr: errs.FromPostgresError(errors.New("test error")).WithParam("{{ .KeyName }}_id", {{ .Variable }}.ID.String()),
        },
        {
            name: "result error",
            setup: func() {
                mock.ExpectExec(query).
                    WithArgs(
                        {{ $.Variable }}.CreatedAt,
                        {{ $.Variable }}.UpdatedAt,
{{- range $value := .Params }}
    {{- if $value.IsSlice }}
                        pq.Array({{ $.Variable }}.{{ $value.GetName }}),
    {{- else }}
                        {{ $.Variable }}.{{ $value.GetName }},
    {{- end }}
{{- end }}
                        {{ $.Variable }}.ID,
                    ).
                    WillReturnResult(sqlmock.NewErrorResult(errors.New("test error")))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx:  ctx,
                {{ .Variable }}: {{ .Variable }},
            },
            wantErr: errs.FromPostgresError(errors.New("test error")).WithParam("{{ .KeyName }}_id", {{ .Variable }}.ID.String()),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            r := &{{ .RepositoryTypeName }}{
                writeDB: tt.fields.writeDB,
                readDB: tt.fields.readDB,
                logger:   tt.fields.logger,
            }
            err := r.Update(tt.args.ctx, tt.args.{{ .Variable }})
            assert.ErrorIs(t, err, tt.wantErr)
        })
    }
}

func Test{{ .RepositoryTypeName }}_Delete(t *testing.T) {
    mockDB, mock, err := postgres.NewMockPostgreSQL(t)
    if err != nil {
        t.Fatal(err)
        return
    }
    defer mockDB.Close()
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mockLogger := NewMocklogger(ctrl)
    {{ .Variable }} := entities.NewMock{{ .EntityName }}(t)
    type fields struct {
        writeDB database
        readDB database
        logger   logger
    }
    type args struct {
        ctx context.Context
        id  uuid.UUID
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        wantErr error
    }{
        {
            name: "ok",
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            setup: func() {
                mock.ExpectExec("DELETE FROM public.{{ .TableName }} WHERE id = $1").
                    WithArgs({{ .Variable }}.ID).
                    WillReturnResult(sqlmock.NewResult(0, 1))
            },
            args: args{
                ctx: context.Background(),
                id:  {{ .Variable }}.ID,
            },
            wantErr: nil,
        },
        {
            name: "{{ .Variable }} not found",
            setup: func() {
                mock.ExpectExec("DELETE FROM public.{{ .TableName }} WHERE id = $1").
                    WithArgs({{ .Variable }}.ID).
                    WillReturnResult(sqlmock.NewResult(0, 0))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx: context.Background(),
                id:  {{ .Variable }}.ID,
            },
            wantErr: errs.NewEntityNotFoundError().WithParam("{{ .KeyName }}_id", {{ .Variable }}.ID.String()),
        },
        {
            name: "database error",
            setup: func() {
                mock.ExpectExec("DELETE FROM public.{{ .TableName }} WHERE id = $1").
                    WithArgs({{ .Variable }}.ID).
                    WillReturnError(errors.New("test error"))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx: context.Background(),
                id:  {{ .Variable }}.ID,
            },
            wantErr: errs.FromPostgresError(errors.New("test error")).WithParam("{{ .KeyName }}_id", {{ .Variable }}.ID.String()),
        },
        {
            name: "result error",
            setup: func() {
                mock.ExpectExec("DELETE FROM public.{{ .TableName }} WHERE id = $1").
                    WithArgs({{ .Variable }}.ID).
                    WillReturnResult(sqlmock.NewErrorResult(errors.New("test error")))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
                logger: mockLogger,
            },
            args: args{
                ctx: context.Background(),
                id:  {{ .Variable }}.ID,
            },
            wantErr: errs.FromPostgresError(errors.New("test error")).WithParam("{{ .KeyName }}_id", {{ .Variable }}.ID.String()),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            r := &{{ .RepositoryTypeName }}{
                writeDB: tt.fields.writeDB,
                readDB: tt.fields.readDB,
                logger:   tt.fields.logger,
            }
            err := r.Delete(tt.args.ctx, tt.args.id)
            assert.ErrorIs(t, err, tt.wantErr)
        })
    }
}

func Test{{ .RepositoryTypeName }}_Count(t *testing.T) {
    mockDB, mock, err := postgres.NewMockPostgreSQL(t)
    if err != nil {
        t.Fatal(err)
        return
    }
    defer mockDB.Close()
    query := "SELECT count(id) FROM public.{{ .TableName }}"
    ctx := context.Background()
    filter := entities.{{ .FilterTypeName }}{}
    type fields struct {
        writeDB database
        readDB database
        logger   logger
    }
    type args struct {
        ctx    context.Context
        filter entities.{{ .FilterTypeName }}
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    uint64
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mock.ExpectQuery(query).
                    WillReturnRows(sqlmock.NewRows([]string{"count"}).
                        AddRow(1))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
            },
            args: args{
                ctx:    ctx,
                filter: filter,
            },
            want:    1,
            wantErr: nil,
        },
        {
            name: "bad return type",
            setup: func() {
                mock.ExpectQuery(query).
                    WillReturnRows(sqlmock.NewRows([]string{"count"}).
                        AddRow("one"))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
            },
            args: args{
                ctx:    ctx,
                filter: filter,
            },
            want: 0,
            wantErr: &errs.Error{
                Code:    13,
                Message: "Unexpected behavior.",
                Params: errs.Params{ {Key: "error", Value: "sql: Scan error on column index 0, name \"count\": converting driver.Value type string (\"one\") to a uint64: invalid syntax"} },
            },
        },
        {
            name: "database error",
            setup: func() {
                mock.ExpectQuery(query).
                    WillReturnError(errors.New("test error"))
            },
            fields: fields{
                writeDB: mockDB,
                readDB: mockDB,
            },
            args: args{
                ctx:    ctx,
                filter: filter,
            },
            want:    0,
            wantErr: errs.FromPostgresError(errors.New("test error")),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            r := &{{ .RepositoryTypeName }}{
                writeDB: tt.fields.writeDB,
                readDB: tt.fields.readDB,
                logger:   tt.fields.logger,
            }
            got, err := r.Count(tt.args.ctx, tt.args.filter)
            assert.ErrorIs(t, err, tt.wantErr)
            assert.Equal(t, tt.want, got)
        })
    }
}

func new{{ .EntityName }}Rows(t *testing.T, {{ .ListVariable }} []entities.{{ .EntityName }}) *sqlmock.Rows {
    t.Helper()
    rows := sqlmock.NewRows([]string{
        "id",
{{- if .Params }}
    {{- range $key, $value := .Params }}
        "{{ $value.Tag }}",
    {{- end }}
{{- else }}
    // TODO: add columns
{{- end }}
        "updated_at",
        "created_at",
    })
    for _, {{ .Variable }} := range {{ .ListVariable }} {
        rows.AddRow(
            {{ .Variable }}.ID,
{{- if .Params }}
{{- range $key, $value := .Params }}
{{- if $value.IsSlice }}
            pq.Array({{ $.Variable }}.{{ $value.GetName }}),
{{- else }}
            {{ $.Variable }}.{{ $value.GetName }},
{{- end }}
{{- end }}
{{- else }}
            // TODO: add values
{{- end }}
            {{ .Variable }}.UpdatedAt,
            {{ .Variable }}.CreatedAt,
        )
    }
    return rows
}
