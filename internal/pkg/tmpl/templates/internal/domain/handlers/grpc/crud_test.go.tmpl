package handlers

import (
    "context"
    "{{ .Module }}/internal/pkg/errs"

    "{{ .Module }}/internal/app/{{ .AppName }}/entities/{{ .DirName }}"
    "{{ .Module }}/internal/pkg/pointer"
    "{{ .Module }}/internal/pkg/uuid"
    {{ .ProtoPackage }} "{{ .Module }}/pkg/{{ .ProtoPackage }}/v1"
    "go.uber.org/mock/gomock"
    "google.golang.org/protobuf/types/known/emptypb"
    "google.golang.org/protobuf/types/known/timestamppb"
    "google.golang.org/protobuf/types/known/wrapperspb"
    "github.com/jaswdr/faker"
    "github.com/stretchr/testify/assert"
    "testing"
)

func TestNew{{ .GRPCHandlerTypeName }}(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mock{{ .UseCaseTypeName }} := NewMock{{ .GetUseCaseInterfaceName }}(ctrl)
    mockLogger := NewMocklogger(ctrl)
    type args struct {
        {{ .UseCaseVariableName }} {{ .GetUseCaseInterfaceName }}
        logger             logger
    }
    tests := []struct {
        name string
        args args
        want {{ .ProtoPackage }}.{{ .GRPCHandlerTypeName }}
    }{
        {
            name: "ok",
            args: args{
                {{ .UseCaseVariableName }}: mock{{ .UseCaseTypeName }},
                logger: mockLogger,
            },
            want: &{{ .GRPCHandlerTypeName }}{
                {{ .UseCaseVariableName }}: mock{{ .UseCaseTypeName }},
                logger: mockLogger,
            },
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := New{{ .GRPCHandlerTypeName }}(tt.args.{{ .UseCaseVariableName }}, tt.args.logger)
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test{{ .GRPCHandlerTypeName }}_Create(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mock{{ .UseCaseTypeName }} := NewMock{{ .GetUseCaseInterfaceName }}(ctrl)
    mockLogger := NewMocklogger(ctrl)
    ctx := context.Background()
    // create := entities.NewMock{{ .CreateTypeName }}(t)
    {{ .Variable }} := entities.NewMock{{ .EntityName }}(t)
    type fields struct {
        Unimplemented{{ .GRPCHandlerTypeName }} {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}
        {{ .UseCaseVariableName }} {{ .GetUseCaseInterfaceName }}
        logger logger
    }
    type args struct {
        ctx   context.Context
        input *{{ .ProtoPackage }}.{{ .CreateTypeName }}
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    *{{ .ProtoPackage }}.{{ .EntityName }}
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mock{{ .UseCaseTypeName }}.
                    EXPECT().
                    Create(ctx, gomock.Any()).
                    Return({{ .Variable }}, nil)
            },
            fields: fields{
                Unimplemented{{ .GRPCHandlerTypeName }}: {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}{},
                {{ .UseCaseVariableName }}: mock{{ .UseCaseTypeName }},
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.{{ .CreateTypeName }}{},
            },
            want:    decode{{ .EntityName }}({{ .Variable }}),
            wantErr: nil,
        },
        {
            name: "usecase error",
            setup: func() {
                mock{{ .UseCaseTypeName }}.
                    EXPECT().
                    Create(ctx, gomock.Any()).
                    Return(entities.{{ .EntityName }}{}, errs.NewUnexpectedBehaviorError("usecase error")).
                    Times(1)
            },
            fields: fields{
                Unimplemented{{ .GRPCHandlerTypeName }}: {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}{},
                {{ .UseCaseVariableName }}: mock{{ .UseCaseTypeName }},
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.{{ .CreateTypeName }}{},
            },
            want:    nil,
            wantErr: errs.NewUnexpectedBehaviorError("usecase error"),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            s := {{ .GRPCHandlerTypeName }}{
                Unimplemented{{ .GRPCHandlerTypeName }}: tt.fields.Unimplemented{{ .GRPCHandlerTypeName }},
                {{ .UseCaseVariableName }}:                tt.fields.{{ .UseCaseVariableName }},
                logger:                            tt.fields.logger,
            }
            got, err := s.Create(tt.args.ctx, tt.args.input)
            assert.ErrorIs(t, err, tt.wantErr)
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test{{ .GRPCHandlerTypeName }}_Delete(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mock{{ .UseCaseTypeName }} := NewMock{{ .GetUseCaseInterfaceName }}(ctrl)
    mockLogger := NewMocklogger(ctrl)
    ctx := context.Background()
    id := uuid.NewUUID()
    type fields struct {
        Unimplemented{{ .GRPCHandlerTypeName }} {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}
        {{ .UseCaseVariableName }}                {{ .GetUseCaseInterfaceName }}
        logger                            logger
    }
    type args struct {
        ctx   context.Context
        input *{{ .ProtoPackage }}.{{ .EntityName }}Delete
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    *emptypb.Empty
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mock{{ .UseCaseTypeName }}.EXPECT().Delete(ctx, id).Return(nil).Times(1)
            },
            fields: fields{
                Unimplemented{{ .GRPCHandlerTypeName }}: {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}{},
                {{ .UseCaseVariableName }}: mock{{ .UseCaseTypeName }},
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.{{ .EntityName }}Delete{
                    Id: id.String(),
                },
            },
            want:    &emptypb.Empty{},
            wantErr: nil,
        },
        {
            name: "usecase error",
            setup: func() {
                mock{{ .UseCaseTypeName }}.EXPECT().Delete(ctx, id).
                    Return(errs.NewUnexpectedBehaviorError("i error")).
                    Times(1)
            },
            fields: fields{
                Unimplemented{{ .GRPCHandlerTypeName }}: {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}{},
                {{ .UseCaseVariableName }}: mock{{ .UseCaseTypeName }},
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.{{ .EntityName }}Delete{
                    Id: id.String(),
                },
            },
            want: nil,
            wantErr: &errs.Error{
                Code:    13,
                Message: "Unexpected behavior.",
                Params: errs.Params{ {Key: "details", Value: "i error"} },
            },
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            s := {{ .GRPCHandlerTypeName }}{
                Unimplemented{{ .GRPCHandlerTypeName }}: tt.fields.Unimplemented{{ .GRPCHandlerTypeName }},
                {{ .UseCaseVariableName }}:                tt.fields.{{ .UseCaseVariableName }},
                logger:                            tt.fields.logger,
            }
            got, err := s.Delete(tt.args.ctx, tt.args.input)
            assert.ErrorIs(t, err, tt.wantErr)
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test{{ .GRPCHandlerTypeName }}_Get(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mock{{ .UseCaseTypeName }} := NewMock{{ .GetUseCaseInterfaceName }}(ctrl)
    mockLogger := NewMocklogger(ctrl)
    ctx := context.Background()
    {{ .Variable }} := entities.NewMock{{ .EntityName }}(t)
    type fields struct {
        Unimplemented{{ .GRPCHandlerTypeName }} {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}
        {{ .UseCaseVariableName }}                {{ .GetUseCaseInterfaceName }}
        logger                            logger
    }
    type args struct {
        ctx   context.Context
        input *{{ .ProtoPackage }}.{{ .EntityName }}Get
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    *{{ .ProtoPackage }}.{{ .EntityName }}
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mock{{ .UseCaseTypeName }}.EXPECT().Get(ctx, {{ .Variable }}.ID).Return({{ .Variable }}, nil).Times(1)
            },
            fields: fields{
                Unimplemented{{ .GRPCHandlerTypeName }}: {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}{},
                {{ .UseCaseVariableName }}: mock{{ .UseCaseTypeName }},
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.{{ .EntityName }}Get{
                    Id: {{ .Variable }}.ID.String(),
                },
            },
            want:    decode{{ .EntityName }}({{ .Variable }}),
            wantErr: nil,
        },
        {
            name: "usecase error",
            setup: func() {
                mock{{ .UseCaseTypeName }}.EXPECT().Get(ctx, {{ .Variable }}.ID).
                    Return(entities.{{ .EntityName }}{}, errs.NewUnexpectedBehaviorError("i error")).
                    Times(1)
            },
            fields: fields{
                Unimplemented{{ .GRPCHandlerTypeName }}: {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}{},
                {{ .UseCaseVariableName }}: mock{{ .UseCaseTypeName }},
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.{{ .EntityName }}Get{
                    Id: {{ .Variable }}.ID.String(),
                },
            },
            want:    nil,
            wantErr: errs.NewUnexpectedBehaviorError("i error"),
        },
    }
    for _, tt := range tests {
        tt.setup()
        t.Run(tt.name, func(t *testing.T) {
            s := {{ .GRPCHandlerTypeName }}{
                Unimplemented{{ .GRPCHandlerTypeName }}: tt.fields.Unimplemented{{ .GRPCHandlerTypeName }},
                {{ .UseCaseVariableName }}:                tt.fields.{{ .UseCaseVariableName }},
                logger:                            tt.fields.logger,
            }
            got, err := s.Get(tt.args.ctx, tt.args.input)
            assert.ErrorIs(t, err, tt.wantErr)
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test{{ .GRPCHandlerTypeName }}_List(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mock{{ .UseCaseTypeName }} := NewMock{{ .GetUseCaseInterfaceName }}(ctrl)
    mockLogger := NewMocklogger(ctrl)
    ctx := context.Background()
    filter := entities.NewMock{{ .FilterTypeName }}(t)
    count := faker.New().UInt64Between(2, 20)
    response := &{{ .ProtoPackage }}.List{{ .EntityName }}{
        Items: make([]*{{ .ProtoPackage }}.{{ .EntityName }}, 0, int(count)),
        Count:    count,
    }
    {{ .ListVariable }} := make([]entities.{{ .EntityName }}, 0, int(count))
    type fields struct {
        Unimplemented{{ .GRPCHandlerTypeName }} {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}
        {{ .UseCaseVariableName }}                {{ .GetUseCaseInterfaceName }}
        logger                            logger
    }
    type args struct {
        ctx   context.Context
        input *{{ .ProtoPackage }}.{{ .FilterTypeName }}
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    *{{ .ProtoPackage }}.List{{ .EntityName }}
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mock{{ .UseCaseTypeName }}.EXPECT().List(ctx, gomock.Any()).Return({{ .ListVariable }}, count, nil).Times(1)
            },
            fields: fields{
                Unimplemented{{ .GRPCHandlerTypeName }}: {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}{},
                {{ .UseCaseVariableName }}: mock{{ .UseCaseTypeName }},
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.{{ .FilterTypeName }}{
                    PageNumber: wrapperspb.UInt64(*filter.PageNumber),
                    PageSize:   wrapperspb.UInt64(*filter.PageSize),
{{- if .SearchEnabled }}
                    Search:     wrapperspb.String(*filter.Search),
{{- end}}
                    OrderBy:    filter.OrderBy,
                },
            },
            want:    response,
            wantErr: nil,
        },
        {
            name: "usecase error",
            setup: func() {
                mock{{ .UseCaseTypeName }}.
                    EXPECT().
                    List(ctx, gomock.Any()).
                    Return(nil, uint64(0), errs.NewUnexpectedBehaviorError("i error")).
                    Times(1)
            },
            fields: fields{
                Unimplemented{{ .GRPCHandlerTypeName }}: {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}{},
                {{ .UseCaseVariableName }}: mock{{ .UseCaseTypeName }},
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.{{ .FilterTypeName }}{
                    PageNumber: wrapperspb.UInt64(*filter.PageNumber),
                    PageSize:   wrapperspb.UInt64(*filter.PageSize),
{{- if .SearchEnabled }}
                    Search:     wrapperspb.String(*filter.Search),
{{- end }}
                    OrderBy:    filter.OrderBy,
                },
            },
            want:    nil,
            wantErr: errs.NewUnexpectedBehaviorError("i error"),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            s := {{ .GRPCHandlerTypeName }}{
                Unimplemented{{ .GRPCHandlerTypeName }}: tt.fields.Unimplemented{{ .GRPCHandlerTypeName }},
                {{ .UseCaseVariableName }}:                tt.fields.{{ .UseCaseVariableName }},
                logger:                            tt.fields.logger,
            }
            got, err := s.List(tt.args.ctx, tt.args.input)
            assert.ErrorIs(t, err, tt.wantErr)
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test{{ .GRPCHandlerTypeName }}_Update(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mock{{ .UseCaseTypeName }} := NewMock{{ .GetUseCaseInterfaceName }}(ctrl)
    mockLogger := NewMocklogger(ctrl)
    ctx := context.Background()
    {{ .Variable }} := entities.NewMock{{ .EntityName }}(t)
    update := entities.NewMock{{ .UpdateTypeName }}(t)
    type fields struct {
        Unimplemented{{ .GRPCHandlerTypeName }} {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}
        {{ .UseCaseVariableName }}                {{ .GetUseCaseInterfaceName }}
        logger                            logger
    }
    type args struct {
        ctx   context.Context
        input *{{ .ProtoPackage }}.{{ .UpdateTypeName }}
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    *{{ .ProtoPackage }}.{{ .EntityName }}
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mock{{ .UseCaseTypeName }}.EXPECT().Update(ctx, gomock.Any()).Return({{ .Variable }}, nil).Times(1)
            },
            fields: fields{
                Unimplemented{{ .GRPCHandlerTypeName }}: {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}{},
                {{ .UseCaseVariableName }}: mock{{ .UseCaseTypeName }},
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                input: decode{{ .UpdateTypeName }}(update),
            },
            want:    decode{{ .EntityName }}({{ .Variable }}),
            wantErr: nil,
        },
        {
            name: "usecase error",
            setup: func() {
                mock{{ .UseCaseTypeName }}.EXPECT().Update(ctx, gomock.Any()).
                    Return(entities.{{ .EntityName }}{}, errs.NewUnexpectedBehaviorError("i error"))
            },
            fields: fields{
                Unimplemented{{ .GRPCHandlerTypeName }}: {{ .ProtoPackage }}.Unimplemented{{ .GRPCHandlerTypeName }}{},
                {{ .UseCaseVariableName }}: mock{{ .UseCaseTypeName }},
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                input: decode{{ .UpdateTypeName }}(update),
            },
            want:    nil,
            wantErr: errs.NewUnexpectedBehaviorError("i error"),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            s := {{ .GRPCHandlerTypeName }}{
                Unimplemented{{ .GRPCHandlerTypeName }}: tt.fields.Unimplemented{{ .GRPCHandlerTypeName }},
                {{ .UseCaseVariableName }}:                tt.fields.{{ .UseCaseVariableName }},
                logger:                            tt.fields.logger,
            }
            got, err := s.Update(tt.args.ctx, tt.args.input)
            assert.ErrorIs(t, err, tt.wantErr)
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test_decode{{ .EntityName }}(t *testing.T) {
    {{ .Variable }} := entities.NewMock{{ .EntityName }}(t)
    result := &{{ .ProtoPackage }}.{{ .EntityName }}{
        Id:          {{ .Variable }}.ID.String(),
        UpdatedAt:   timestamppb.New({{ .Variable }}.UpdatedAt),
        CreatedAt:   timestamppb.New({{ .Variable }}.CreatedAt),
        {{- range $value := .Params }}
            {{- if $value.IsSlice }}
        {{ $value.GRPCParam }}: {{ $value.GRPCType }}{},
            {{- else if $value.IsID }}
        {{ $value.GRPCParam }}: {{ $.Variable }}.{{ $value.GetName }}.String(),
            {{- else }}
        {{ $value.GRPCParam }}: {{ $value.GRPCType }}({{ $.Variable }}.{{ $value.GetName }}),
            {{- end }}
        {{- end }}
    }
{{- range $value := .Params }}
    {{- if $value.IsSlice }}
    for _, param := range {{ $.Variable }}.{{ $value.GetName }} {
        result.{{ $value.GRPCParam }} = append(result.{{ $value.GRPCParam }}, {{ $value.GRPCSliceType }}(param))
    }
    {{- end }}
{{- end }}
    type args struct {
        {{ .Variable }} entities.{{ .EntityName }}
    }
    tests := []struct {
        name string
        args args
        want *{{ .ProtoPackage }}.{{ .EntityName }}
    }{
        {
            name: "ok",
            args: args{
                {{ .Variable }}: {{ .Variable }},
            },
            want: result,
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := decode{{ .EntityName }}(tt.args.{{ .Variable }})
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test_encode{{ .FilterTypeName }}(t *testing.T) {
    type args struct {
        input *{{ .ProtoPackage }}.{{ .FilterTypeName }}
    }
    tests := []struct {
        name string
        args args
        want entities.{{ .FilterTypeName }}
    }{
        {
            name: "ok",
            args: args{
                input: &{{ .ProtoPackage }}.{{ .FilterTypeName }}{
                    PageNumber: wrapperspb.UInt64(2),
                    PageSize:   wrapperspb.UInt64(5),
{{- if .SearchEnabled }}
                    Search:     wrapperspb.String("my name is"),
{{- end}}
                    OrderBy:    []string{"created_at", "id"},
                },
            },
            want: entities.{{ .FilterTypeName }}{
                PageSize:   pointer.Of(uint64(5)),
                PageNumber: pointer.Of(uint64(2)),
                OrderBy:    []string{"created_at", "id"},
{{- if .SearchEnabled }}
                Search:     pointer.Of("my name is"),
{{- end}}
            },
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := encode{{ .FilterTypeName }}(tt.args.input)
            assert.Equal(t, tt.want, got)
        })
    }
}
