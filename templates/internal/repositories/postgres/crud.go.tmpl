package postgres

import (
    "context"
    "fmt"
{{- range $value := .Params }}
    {{- if .IsSlice }}
    "github.com/lib/pq"
    {{- break }}
    {{- end }}
{{- end }}
    "time"

    sq "github.com/Masterminds/squirrel"

    "{{ .Module }}/pkg/log"

    "{{ .Module }}/internal/domain/models"
    "{{ .Module }}/internal/domain/repositories"

    "{{ .Module }}/internal/domain/errs"
{{- if .SearchEnabled }}
    "{{ .Module }}/pkg/postgresql"
{{- end }}
    "{{ .Module }}/pkg/utils"
    "github.com/jmoiron/sqlx"
)


type {{ .PostgresDTOTypeName }} struct {
	ID          string         `db:"id,omitempty"`
{{- range $value := .Params }}
    {{ $value.GetName }} {{ $value.PostgresDTOType }} `db:"{{ $value.Tag }}"`
{{- end }}
	UpdatedAt   time.Time      `db:"updated_at,omitempty"`
	CreatedAt   time.Time      `db:"created_at,omitempty"`
}

func New{{ .PostgresDTOTypeName }}FromModel({{ .Variable }} *models.{{ .ModelName }}) *{{ .PostgresDTOTypeName }} {
	dto := &{{ .PostgresDTOTypeName }}{
		ID:          string({{ .Variable }}.ID),
{{- range $value := .Params }}
    {{- if $value.IsSlice }}
        {{ $value.GetName }}: {{ $value.PostgresDTOType }}{},
    {{- else }}
        {{ $value.GetName }}: {{ $value.PostgresDTOType }}({{ $.Variable }}.{{ $value.GetName }}),
    {{- end }}
{{- end }}
		UpdatedAt:   {{ .Variable }}.UpdatedAt,
		CreatedAt:   {{ .Variable }}.CreatedAt,
	}
{{- range $value := .Params }}
    {{- if $value.IsSlice }}
    for _, param := range {{ $.Variable }}.{{ $value.GetName }} {
        dto.{{ $value.GetName }} = append(dto.{{ $value.GetName }}, {{ .PostgresDTOSliceType }}(param))
    }
    {{- end }}
{{- end }}
	return dto
}

func (dto *{{ .PostgresDTOTypeName }}) ToModel() *models.{{ .ModelName }} {
	model := &models.{{ .ModelName }}{
		ID:          models.UUID(dto.ID),
{{- range $value := .Params }}
    {{- if $value.IsSlice }}
        {{ $value.GetName }}: {{ $value.Type }}{},
    {{- else }}
        {{ $value.GetName }}: {{ $value.Type }}(dto.{{ $value.GetName }}),
    {{- end }}
{{- end }}
		UpdatedAt:   dto.UpdatedAt,
		CreatedAt:   dto.CreatedAt,
	}
{{- range $value := .Params }}
    {{- if $value.IsSlice }}
        for _, param := range dto.{{ $value.GetName }} {
            model.{{ $value.GetName }} = append(model.{{ $value.GetName }}, {{ .SliceType }}(param))
        }
    {{- end }}
{{- end }}
	return model
}

type {{ .PostgresDTOListTypeName }} []*{{ .PostgresDTOTypeName }}

func (list {{ .PostgresDTOListTypeName }}) ToModels() []*models.{{ .ModelName }} {
    {{ .ListVariable }} := make([]*models.{{ .ModelName }}, len(list))
	for i := range list {
        {{ .ListVariable }}[i] = list[i].ToModel()
	}
	return {{ .ListVariable }}
}

func (r *{{ .RepositoryTypeName }}) Get(
    ctx context.Context,
    id models.UUID,
) (*models.{{ .ModelName }}, error ) {
    ctx, cancel := context.WithTimeout(ctx, time.Second)
    defer cancel()
    dto := &{{ .PostgresDTOTypeName }}{}
    q := sq.Select(
        "{{ .TableName }}.id",
{{- range $key, $value := .Params }}
        "{{ $.TableName }}.{{ $value.Tag }}",
{{- end }}
        "{{ .TableName }}.updated_at",
        "{{ .TableName }}.created_at",
    ).
        From("public.{{ .TableName }}").
        Where(sq.Eq{"id": id}).
        Limit(1)
    query, args := q.PlaceholderFormat(sq.Dollar).MustSql()
    if err := r.database.GetContext(ctx, dto, query, args...); err != nil {
        e := errs.FromPostgresError(err).
            WithParam("{{ .KeyName }}_id", string(id))
        return nil, e
    }
    return dto.ToModel(), nil
}

func (r *{{ .RepositoryTypeName }}) List(
    ctx context.Context,
    filter *models.{{ .FilterTypeName }},
) ([]*models.{{ .ModelName }}, error ) {
    ctx, cancel := context.WithTimeout(ctx, time.Second)
    defer cancel()
    var dto {{ .PostgresDTOListTypeName }}
    const pageSize = uint64(10)
    if filter.PageSize == nil {
        filter.PageSize = utils.Pointer(pageSize)
    }
    q := sq.Select(
        "{{ .TableName }}.id",
{{- range $value := .Params }}
        "{{ $.TableName }}.{{ $value.Tag }}",
{{- end }}
        "{{ .TableName }}.updated_at",
        "{{ .TableName }}.created_at",
    ).
        From("public.{{ .TableName }}").
        Limit(pageSize)
{{- if .SearchEnabled }}
    if filter.Search != nil {
        q = q.Where(postgresql.Search{
            Lang:   "english",
            Query:  *filter.Search,
            Fields: []string{
{{- range $value := .Params }}
{{- if $value.Search }}
                "{{ $value.Tag }}",
{{- end }}
{{- end }}
            },
        })
    }
{{- end }}
    if filter.PageNumber != nil && *filter.PageNumber > 1 {
        q = q.Offset((*filter.PageNumber - 1) * *filter.PageSize)
    }
    q = q.Limit(*filter.PageSize)
    if len(filter.OrderBy) > 0 {
        q = q.OrderBy(filter.OrderBy...)
    }
    query, args := q.PlaceholderFormat(sq.Dollar).MustSql()
    if err := r.database.SelectContext(ctx, &dto, query, args...); err != nil {
        e := errs.FromPostgresError(err)
        return nil, e
    }
    return dto.ToModels(), nil
}

func (r *{{ .RepositoryTypeName }}) Update(
    ctx context.Context,
    {{ .Variable }} *models.{{ .ModelName }},
) error {
    ctx, cancel := context.WithTimeout(ctx, time.Second)
    defer cancel()
    dto := New{{ .PostgresDTOTypeName }}FromModel({{ .Variable }})
    q := sq.Update("public.{{ .TableName }}").
        Where(sq.Eq{"id": {{ .Variable }}.ID}).
    {{- range $key, $value := .Params }}
        Set("{{ $.TableName }}.{{ $value.Tag }}", dto.{{ $value.GetName }}).
    {{- end }}
        Set("updated_at", {{ .Variable }}.UpdatedAt)
    query, args := q.PlaceholderFormat(sq.Dollar).MustSql()
    result, err := r.database.ExecContext(ctx, query, args...)
    if err != nil {
        e := errs.FromPostgresError(err).
            WithParam("{{ .KeyName }}_id", fmt.Sprint({{ .Variable }}.ID))
        return e
    }
    affected, err := result.RowsAffected()
    if err != nil {
        return errs.FromPostgresError(err).
            WithParam("{{ .KeyName }}_id", fmt.Sprint({{ .Variable }}.ID))
    }
    if affected == 0 {
        e := errs.NewEntityNotFound().
            WithParam("{{ .KeyName }}_id", fmt.Sprint({{ .Variable }}.ID))
        return e
    }
    return nil
}

func (r *{{ .RepositoryTypeName }}) Delete(
    ctx context.Context,
    id models.UUID,
) error {
    ctx, cancel := context.WithTimeout(ctx, time.Second)
    defer cancel()
    q := sq.Delete("public.{{ .TableName }}").Where(sq.Eq{"id": id})
    query, args := q.PlaceholderFormat(sq.Dollar).MustSql()
    result, err := r.database.ExecContext(ctx, query, args...)
    if err != nil {
        e := errs.FromPostgresError(err).
            WithParam("{{ .KeyName }}_id", fmt.Sprint(id))
        return e
    }
    affected, err := result.RowsAffected()
    if err != nil {
        e := errs.FromPostgresError(err).
            WithParam("{{ .KeyName }}_id", fmt.Sprint(id))
        return e
    }
    if affected == 0 {
        e := errs.NewEntityNotFound().
            WithParam("{{ .KeyName }}_id", fmt.Sprint(id))
        return e
    }
    return nil
}

func (r *{{ .RepositoryTypeName }}) Count(
    ctx context.Context,
    filter *models.{{ .FilterTypeName }},
) (uint64, error ) {
    ctx, cancel := context.WithTimeout(ctx, time.Second)
    defer cancel()
    q := sq.Select("count(id)").From("public.{{ .TableName }}")
    query, args := q.PlaceholderFormat(sq.Dollar).MustSql()
    result := r.database.QueryRowxContext(ctx, query, args...)
    if err := result.Err(); err != nil {
        e := errs.FromPostgresError(err)
        return 0, e
    }
    var count uint64
    if err := result.Scan(&count); err != nil {
        e := errs.FromPostgresError(err)
        return 0, e
    }
    return count, nil
}
