package usecases

import (
    "context"
    "testing"

    "{{ .Module }}/internal/pkg/errs"
    "{{ .Module }}/internal/app/{{ .AppName }}/entities/{{ .DirName }}"
    "go.uber.org/mock/gomock"
    "github.com/jaswdr/faker"
    "github.com/stretchr/testify/assert"

    "{{ .Module }}/internal/pkg/dtx"
    "{{ .Module }}/internal/pkg/uuid"
)

func TestNew{{ .GetUseCaseTypeName }}(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mock{{ .ServiceTypeName }} := NewMock{{ .GetServiceInterfaceName }}(ctrl)
{{- if .KafkaEnabled }}
    mock{{ .EventServiceName }} := NewMock{{ .EventServiceInterfaceName }}(ctrl)
{{- end}}
    mockDtxManager := NewMockdtxManager(ctrl)
    mockLogger := NewMocklogger(ctrl)
    type args struct {
        {{ .ServiceVariableName }} {{ .GetServiceInterfaceName }}
{{- if .KafkaEnabled }}
        {{ .EventServicePrivateVariableName }} {{ .EventServiceInterfaceName }}
{{- end}}
        dtxManager dtxManager
        logger          logger
    }
    tests := []struct {
        name  string
        setup func()
        args  args
        want  *{{ .GetUseCaseTypeName }}
    }{
        {
            name:  "ok",
            setup: func() {},
            args: args{
                {{ .ServiceVariableName }}: mock{{ .ServiceTypeName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }} : mock{{ .EventServiceName }},
{{- end}}
                dtxManager: mockDtxManager,
                logger: mockLogger,
            },
            want: &{{ .GetUseCaseTypeName }}{
                {{ .ServiceVariableName }}: mock{{ .ServiceTypeName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }} : mock{{ .EventServiceName }},
{{- end}}
                dtxManager: mockDtxManager,
                logger: mockLogger,
            },
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            got := New{{ .GetUseCaseTypeName }}(tt.args.{{ .ServiceVariableName }}, {{- if .KafkaEnabled }}tt.args.{{ .EventServicePrivateVariableName }},{{- end}} tt.args.dtxManager, tt.args.logger)
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test{{ .GetUseCaseTypeName }}_Get(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mock{{ .ServiceTypeName }} := NewMock{{ .GetServiceInterfaceName }}(ctrl)
{{- if .KafkaEnabled }}
    mock{{ .EventServiceName }} := NewMock{{ .EventServiceInterfaceName }}(ctrl)
{{- end}}
    mockLogger := NewMocklogger(ctrl)
    mockDtxManager := NewMockdtxManager(ctrl)
    ctx := context.Background()
    {{ .Variable }} := entities.NewMock{{ .EntityName }}(t)
    type fields struct {
        {{ .ServiceVariableName }} {{ .GetServiceInterfaceName }}
{{- if .KafkaEnabled }}
        {{ .EventServicePrivateVariableName }} {{ .EventServiceInterfaceName }}
{{- end}}
        dtxManager dtxManager
        logger          logger
    }
    type args struct {
        ctx context.Context
        id  uuid.UUID
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    entities.{{ .EntityName }}
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mock{{ .ServiceTypeName }}.EXPECT().
                    Get(ctx, {{ .Variable }}.ID).
                    Return({{ .Variable }}, nil)
            },
            fields: fields{
                {{ .ServiceVariableName }}: mock{{ .ServiceTypeName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: mock{{ .EventServiceName }},
{{- end}}
                dtxManager: mockDtxManager,
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                id:  uuid.UUID({{ .Variable }}.ID),
            },
            want:    {{ .Variable }},
            wantErr: nil,
        },
        {
            name: "{{ .EntityName }} not found",
            setup: func() {
                mock{{ .ServiceTypeName }}.EXPECT().
                    Get(ctx, {{ .Variable }}.ID).
                    Return(entities.{{ .EntityName }}{}, errs.NewEntityNotFoundError())
            },
            fields: fields{
                {{ .ServiceVariableName }}: mock{{ .ServiceTypeName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: mock{{ .EventServiceName }},
{{- end}}
                dtxManager: mockDtxManager,
                logger: mockLogger,
            },
            args: args{
                ctx:         ctx,
                id:          {{ .Variable }}.ID,
            },
            want:    entities.{{ .EntityName }}{},
            wantErr: errs.NewEntityNotFoundError(),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            i := &{{ .GetUseCaseTypeName }}{
                {{ .ServiceVariableName }}: tt.fields.{{ .ServiceVariableName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: tt.fields.{{ .EventServicePrivateVariableName }},
{{- end}}
                dtxManager: tt.fields.dtxManager,
                logger:          tt.fields.logger,
            }
            got, err := i.Get(tt.args.ctx, tt.args.id)
            assert.ErrorIs(t, err, tt.wantErr)
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test{{ .GetUseCaseTypeName }}_Create(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mock{{ .ServiceTypeName }} := NewMock{{ .GetServiceInterfaceName }}(ctrl)
{{- if .KafkaEnabled }}
    mock{{ .EventServiceName }} := NewMock{{ .EventServiceInterfaceName }}(ctrl)
{{- end}}
    mockLogger := NewMocklogger(ctrl)
    mockLogger.EXPECT().WithContext(gomock.Any()).Return(mockLogger).AnyTimes()
	mockDtxManager := NewMockdtxManager(ctrl)
	mockTx := dtx.NewMockTX(ctrl)
    ctx := context.Background()
    {{ .Variable }} := entities.NewMock{{ .EntityName }}(t)
    create := entities.NewMock{{ .CreateTypeName }}(t)
    type fields struct {
        {{ .ServiceVariableName }} {{ .GetServiceInterfaceName }}
{{- if .KafkaEnabled }}
        {{ .EventServicePrivateVariableName }} {{ .EventServiceInterfaceName }}
{{- end}}
        dtxManager      dtxManager
        logger          logger
    }
    type args struct {
        ctx    context.Context
        create entities.{{ .CreateTypeName }}
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    entities.{{ .EntityName }}
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mockDtxManager.EXPECT().NewTx().Return(mockTx)
                mock{{ .ServiceTypeName }}.EXPECT().Create(ctx, mockTx, create).Return({{ .Variable }}, nil)
{{- if .KafkaEnabled }}
                mock{{ .EventServiceName }}.EXPECT().Created(ctx, mockTx, {{ .Variable }}).Return(nil)
{{- end}}
                mockTx.EXPECT().Rollback().After(mockTx.EXPECT().Commit().Return(nil)).Return(nil)
            },
            fields: fields{
                {{ .ServiceVariableName }}: mock{{ .ServiceTypeName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: mock{{ .EventServiceName }},
{{- end}}
                dtxManager: mockDtxManager,
                logger: mockLogger,
            },
            args: args{
                ctx:    ctx,
                create: create,
            },
            want:    {{ .Variable }},
            wantErr: nil,
        },
        {
            name: "create error",
            setup: func() {
                mockDtxManager.EXPECT().NewTx().Return(mockTx)
                mock{{ .ServiceTypeName }}.EXPECT().
                    Create(ctx, mockTx, create).
                    Return(entities.{{ .EntityName }}{}, errs.NewUnexpectedBehaviorError("c u"))
                mockTx.EXPECT().Rollback().Return(nil)
            },
            fields: fields{
                {{ .ServiceVariableName }}: mock{{ .ServiceTypeName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: mock{{ .EventServiceName }},
{{- end}}
                dtxManager: mockDtxManager,
                logger: mockLogger,
            },
            args: args{
                ctx:    ctx,
                create: create,
            },
            want:    entities.{{ .EntityName }}{},
            wantErr: errs.NewUnexpectedBehaviorError("c u"),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            i := &{{ .GetUseCaseTypeName }}{
                {{ .ServiceVariableName }}: tt.fields.{{ .ServiceVariableName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: tt.fields.{{ .EventServicePrivateVariableName }},
{{- end}}
				dtxManager: tt.fields.dtxManager,
                logger: tt.fields.logger,
            }
            got, err := i.Create(tt.args.ctx, tt.args.create)
            assert.ErrorIs(t, err, tt.wantErr)
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test{{ .GetUseCaseTypeName }}_Update(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mock{{ .ServiceTypeName }} := NewMock{{ .GetServiceInterfaceName }}(ctrl)
{{- if .KafkaEnabled }}
    mock{{ .EventServiceName }} := NewMock{{ .EventServiceInterfaceName }}(ctrl)
{{- end}}
    mockLogger := NewMocklogger(ctrl)
    mockLogger.EXPECT().WithContext(gomock.Any()).Return(mockLogger).AnyTimes()
    mockDtxManager := NewMockdtxManager(ctrl)
    mockTx := dtx.NewMockTX(ctrl)
    ctx := context.Background()
    {{ .Variable }} := entities.NewMock{{ .EntityName }}(t)
    update := entities.NewMock{{ .UpdateTypeName }}(t)
    type fields struct {
        {{ .ServiceVariableName }} {{ .GetServiceInterfaceName }}
{{- if .KafkaEnabled }}
        {{ .EventServicePrivateVariableName }} {{ .EventServiceInterfaceName }}
{{- end}}
        dtxManager      dtxManager
        logger          logger
    }
    type args struct {
        ctx    context.Context
        update entities.{{ .UpdateTypeName }}
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    entities.{{ .EntityName }}
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mockDtxManager.EXPECT().NewTx().Return(mockTx)
                mock{{ .ServiceTypeName }}.EXPECT().Update(ctx, mockTx, update).Return({{ .Variable }}, nil)
{{- if .KafkaEnabled }}
                mock{{ .EventServiceName }}.EXPECT().Updated(ctx, mockTx, {{ .Variable }}).Return(nil)
{{- end}}
                mockTx.EXPECT().Rollback().After(mockTx.EXPECT().Commit().Return(nil)).Return(nil)
            },
            fields: fields{
                {{ .ServiceVariableName }}: mock{{ .ServiceTypeName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: mock{{ .EventServiceName }},
{{- end}}
                dtxManager: mockDtxManager,
                logger: mockLogger,
            },
            args: args{
                ctx:    ctx,
                update: update,
            },
            want:    {{ .Variable }},
            wantErr: nil,
        },
        {
            name: "update error",
            setup: func() {
                mockDtxManager.EXPECT().NewTx().Return(mockTx)
                mock{{ .ServiceTypeName }}.EXPECT().
                    Update(ctx, mockTx, update).
                    Return(entities.{{ .EntityName }}{}, errs.NewUnexpectedBehaviorError("d 2"))
                mockTx.EXPECT().Rollback().Return(nil)
            },
            fields: fields{
                {{ .ServiceVariableName }}: mock{{ .ServiceTypeName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: mock{{ .EventServiceName }},
{{- end}}
                dtxManager: mockDtxManager,
                logger: mockLogger,
            },
            args: args{
                ctx:    ctx,
                update: update,
            },
            want:    entities.{{ .EntityName }}{},
            wantErr: errs.NewUnexpectedBehaviorError("d 2"),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            i := &{{ .GetUseCaseTypeName }}{
                {{ .ServiceVariableName }}: tt.fields.{{ .ServiceVariableName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: tt.fields.{{ .EventServicePrivateVariableName }},
{{- end}}
                dtxManager: tt.fields.dtxManager,
                logger:          tt.fields.logger,
            }
            got, err := i.Update(tt.args.ctx, tt.args.update)
            assert.ErrorIs(t, err, tt.wantErr)
            assert.Equal(t, tt.want, got)
        })
    }
}

func Test{{ .GetUseCaseTypeName }}_Delete(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mock{{ .ServiceTypeName }} := NewMock{{ .GetServiceInterfaceName }}(ctrl)
{{- if .KafkaEnabled }}
    mock{{ .EventServiceName }} := NewMock{{ .EventServiceInterfaceName }}(ctrl)
{{- end}}
    mockLogger := NewMocklogger(ctrl)
    mockLogger.EXPECT().WithContext(gomock.Any()).Return(mockLogger).AnyTimes()
    mockDtxManager := NewMockdtxManager(ctrl)
    mockTx := dtx.NewMockTX(ctrl)
    ctx := context.Background()
    {{ .Variable }} := entities.NewMock{{ .EntityName }}(t)
    type fields struct {
        {{ .ServiceVariableName }} {{ .GetServiceInterfaceName }}
{{- if .KafkaEnabled }}
        {{ .EventServicePrivateVariableName }} {{ .EventServiceInterfaceName }}
{{- end}}
        dtxManager      dtxManager
        logger          logger
    }
    type args struct {
        ctx context.Context
        id  uuid.UUID
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mockDtxManager.EXPECT().NewTx().Return(mockTx)
                mock{{ .ServiceTypeName }}.EXPECT().
                    Delete(ctx, mockTx, {{ .Variable }}.ID).
                    Return(nil)
{{- if .KafkaEnabled }}
                mock{{ .EventServiceName }}.EXPECT().Deleted(ctx, mockTx, {{ .Variable }}.ID).Return(nil)
{{- end}}
                mockTx.EXPECT().Rollback().After(mockTx.EXPECT().Commit().Return(nil)).Return(nil)
            },
            fields: fields{
                {{ .ServiceVariableName }}: mock{{ .ServiceTypeName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: mock{{ .EventServiceName }},
{{- end}}
                dtxManager: mockDtxManager,
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                id:  {{ .Variable }}.ID,
            },
            wantErr: nil,
        },
        {
            name: "delete error",
            setup: func() {
                mockDtxManager.EXPECT().NewTx().Return(mockTx)
                mock{{ .ServiceTypeName }}.EXPECT().
                    Delete(ctx, mockTx, {{ .Variable }}.ID).
                    Return(errs.NewUnexpectedBehaviorError("d 2"))
                mockTx.EXPECT().Rollback().Return(nil)
            },
            fields: fields{
                {{ .ServiceVariableName }}: mock{{ .ServiceTypeName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: mock{{ .EventServiceName }},
{{- end}}
                dtxManager: mockDtxManager,
                logger: mockLogger,
            },
            args: args{
                ctx: ctx,
                id:  {{ .Variable }}.ID,
            },
            wantErr: errs.NewUnexpectedBehaviorError("d 2"),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            i := &{{ .GetUseCaseTypeName }}{
                {{ .ServiceVariableName }}: tt.fields.{{ .ServiceVariableName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: tt.fields.{{ .EventServicePrivateVariableName }},
{{- end}}
                dtxManager: tt.fields.dtxManager,
                logger:          tt.fields.logger,
            }
            err := i.Delete(tt.args.ctx, tt.args.id)
            assert.ErrorIs(t, err, tt.wantErr)
        })
    }
}

func Test{{ .GetUseCaseTypeName }}_List(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    mock{{ .ServiceTypeName }} := NewMock{{ .GetServiceInterfaceName }}(ctrl)
{{- if .KafkaEnabled }}
    mock{{ .EventServiceName }} := NewMock{{ .EventServiceInterfaceName }}(ctrl)
{{- end}}
    mockLogger := NewMocklogger(ctrl)
    mockDtxManager := NewMockdtxManager(ctrl)
    ctx := context.Background()
    filter := entities.NewMock{{ .FilterTypeName }}(t)
    count := faker.New().UInt64Between(2, 20)
    {{ .ListVariable }} := make([]entities.{{ .EntityName }}, 0, count)
    for i := uint64(0); i < count; i++ {
        {{ .ListVariable }} = append({{ .ListVariable }}, entities.NewMock{{ .EntityName }}(t))
    }
    type fields struct {
        {{ .ServiceVariableName }} {{ .GetServiceInterfaceName }}
{{- if .KafkaEnabled }}
        {{ .EventServicePrivateVariableName }} {{ .EventServiceInterfaceName }}
{{- end}}
        dtxManager      dtxManager
        logger          logger
    }
    type args struct {
        ctx         context.Context
        filter      entities.{{ .FilterTypeName }}
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    []entities.{{ .EntityName }}
        want1   uint64
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                mock{{ .ServiceTypeName }}.EXPECT().
                    List(ctx, filter).
                    Return({{ .ListVariable }}, count, nil)
            },
            fields: fields{
                {{ .ServiceVariableName }}: mock{{ .ServiceTypeName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: mock{{ .EventServiceName }},
{{- end}}
                dtxManager: mockDtxManager,
                logger: mockLogger,
            },
            args: args{
                ctx:         ctx,
                filter:      filter,
            },
            want:    {{ .ListVariable }},
            want1:   count,
            wantErr: nil,
        },
        {
            name: "list error",
            setup: func() {
                mock{{ .ServiceTypeName }}.EXPECT().
                    List(ctx, filter).
                    Return(nil, uint64(0), errs.NewUnexpectedBehaviorError("l e"))
            },
            fields: fields{
                {{ .ServiceVariableName }}: mock{{ .ServiceTypeName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: mock{{ .EventServiceName }},
{{- end}}
                dtxManager: mockDtxManager,
                logger: mockLogger,
            },
            args: args{
                ctx:         ctx,
                filter:      filter,
            },
            want:    nil,
            want1:   0,
            wantErr: errs.NewUnexpectedBehaviorError("l e"),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            i := &{{ .GetUseCaseTypeName }}{
                {{ .ServiceVariableName }}: tt.fields.{{ .ServiceVariableName }},
{{- if .KafkaEnabled }}
                {{ .EventServicePrivateVariableName }}: tt.fields.{{ .EventServicePrivateVariableName }},
{{- end}}
                dtxManager: tt.fields.dtxManager,
                logger:          tt.fields.logger,
            }
            got, got1, err := i.List(tt.args.ctx, tt.args.filter)
            assert.ErrorIs(t, err, tt.wantErr)
            assert.Equal(t, tt.want, got)
            assert.Equal(t, tt.want1, got1)
        })
    }
}
