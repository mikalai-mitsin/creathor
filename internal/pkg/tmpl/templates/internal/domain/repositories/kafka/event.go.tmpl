package repositories

import (
	"context"
	"encoding/json"
    "{{ .Module }}/internal/app/{{ .AppName }}/entities/{{ .DirName }}"
	"{{ .Module }}/internal/pkg/clock"
	"{{ .Module }}/internal/pkg/kafka"
)

const (
	topicEventCreated = "{{ .CreatedTopicName }}"
	topicEventUpdated = "{{ .UpdatedTopicName }}"
	topicEventDeleted = "{{ .DeletedTopicName }}"
)

type {{ .EventProducerTypeName }} struct {
	producer producer
	logger   logger
}

func {{ .EventProducerConstructorName }}(
	producer producer,
	logger logger,
) *{{ .EventProducerTypeName }} {
	return &{{ .EventProducerTypeName }}{producer: producer, logger: logger}
}

func (p *{{ .EventProducerTypeName }}) Created(ctx context.Context, {{ .GetOneVariableName }} entities.{{ .GetMainModel.Name }}) error {
	data, err := json.Marshal({{ .GetOneVariableName }})
	if err != nil {
		return err
	}
	message := &kafka.Message{
		Topic: topicEventCreated,
		Value: data,
        Key:   {{ .GetOneVariableName }}.ID.String(),
	}
	if err := p.producer.Send(ctx, message); err != nil {
		return errs.FromKafkaError(err)
	}
	return nil
}

func (p *{{ .EventProducerTypeName }}) Updated(ctx context.Context, {{ .GetOneVariableName }} entities.{{ .GetMainModel.Name }}) error {
	data, err := json.Marshal({{ .GetOneVariableName }})
	if err != nil {
		return err
	}
	message := &kafka.Message{
		Topic: topicEventUpdated,
		Value: data,
        Key:   {{ .GetOneVariableName }}.ID.String(),
	}
	if err := p.producer.Send(ctx, message); err != nil {
		return errs.FromKafkaError(err)
	}
	return nil
}

func (p *{{ .EventProducerTypeName }}) Deleted(ctx context.Context, id uuid.UUID) error {
	message := &kafka.Message{
		Topic: topicEventDeleted,
		Value: []byte(id.String()),
        Key:   id.String(),
	}
	if err := p.producer.Send(ctx, message); err != nil {
		return errs.FromKafkaError(err)
	}
	return nil
}
