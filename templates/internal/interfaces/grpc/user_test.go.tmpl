package grpc

import (
    "context"
    "errors"
    "{{ .Module }}/pkg/{{ .ProtoPackage }}"
    "{{ .Module }}/pkg/utils"
    "reflect"
    "syreclabs.com/go/faker"
    "testing"

    "{{ .Module }}/internal/domain/errs"
    "{{ .Module }}/internal/domain/interceptors"
    mock_interceptors "{{ .Module }}/internal/domain/interceptors/mock"
    "{{ .Module }}/internal/domain/models"
    mock_models "{{ .Module }}/internal/domain/models/mock"
    "{{ .Module }}/pkg/log"
    mock_log "{{ .Module }}/pkg/log/mock"
    "github.com/golang/mock/gomock"
    "github.com/google/uuid"
    "google.golang.org/protobuf/types/known/emptypb"
    "google.golang.org/protobuf/types/known/timestamppb"
    "google.golang.org/protobuf/types/known/wrapperspb"
)

func TestNewUserServiceServer(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    userInterceptor := mock_interceptors.NewMockUserInterceptor(ctrl)
    logger := mock_log.NewMockLogger(ctrl)
    type args struct {
        userInterceptor interceptors.UserInterceptor
        logger          log.Logger
    }
    tests := []struct {
        name string
        args args
        want {{ .ProtoPackage }}.UserServiceServer
    }{
        {
            name: "ok",
            args: args{
                userInterceptor: userInterceptor,
                logger:          logger,
            },
            want: &UserServiceServer{
                userInterceptor: userInterceptor,
                logger:          logger,
            },
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := NewUserServiceServer(tt.args.userInterceptor, tt.args.logger); !reflect.DeepEqual(got, tt.want) {
                t.Errorf("NewUserServiceServer() = %v, want %v", got, tt.want)
            }
        })
    }
}

func TestUserServiceServer_Delete(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    userInterceptor := mock_interceptors.NewMockUserInterceptor(ctrl)
    logger := mock_log.NewMockLogger(ctrl)
    ctx := context.Background()
    user := mock_models.NewUser(t)
    ctx = context.WithValue(ctx, UserKey, user)
    userID := uuid.NewString()
    type fields struct {
        UnimplementedUserServiceServer {{ .ProtoPackage }}.UnimplementedUserServiceServer
        userInterceptor                interceptors.UserInterceptor
        logger                         log.Logger
    }
    type args struct {
        ctx   context.Context
        input *{{ .ProtoPackage }}.UserDelete
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    *emptypb.Empty
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                userInterceptor.EXPECT().Delete(ctx, userID, user).Return(nil).Times(1)
            },
            fields: fields{
                UnimplementedUserServiceServer: {{ .ProtoPackage }}.UnimplementedUserServiceServer{},
                userInterceptor:                userInterceptor,
                logger:                         logger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.UserDelete{
                    Id: userID,
                },
            },
            want:    &emptypb.Empty{},
            wantErr: nil,
        },
        {
            name: "interceptor error",
            setup: func() {
                userInterceptor.EXPECT().Delete(ctx, userID, user).
                    Return(errs.NewUnexpectedBehaviorError("i error")).
                    Times(1)
            },
            fields: fields{
                UnimplementedUserServiceServer: {{ .ProtoPackage }}.UnimplementedUserServiceServer{},
                userInterceptor:                userInterceptor,
                logger:                         logger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.UserDelete{
                    Id: userID,
                },
            },
            want: nil,
            wantErr: decodeError(&errs.Error{
                Code:    13,
                Message: "Unexpected behavior.",
                Params: map[string]string{
                    "details": "i error",
                },
            }),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            u := UserServiceServer{
                UnimplementedUserServiceServer: tt.fields.UnimplementedUserServiceServer,
                userInterceptor:                tt.fields.userInterceptor,
                logger:                         tt.fields.logger,
            }
            got, err := u.Delete(tt.args.ctx, tt.args.input)
            if !errors.Is(err, tt.wantErr) {
                t.Errorf("Delete() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("Delete() got = %v, want %v", got, tt.want)
            }
        })
    }
}

func TestUserServiceServer_Get(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    userInterceptor := mock_interceptors.NewMockUserInterceptor(ctrl)
    logger := mock_log.NewMockLogger(ctrl)
    ctx := context.Background()
    user := mock_models.NewUser(t)
    ctx = context.WithValue(ctx, UserKey, user)
    type fields struct {
        UnimplementedUserServiceServer {{ .ProtoPackage }}.UnimplementedUserServiceServer
        userInterceptor                interceptors.UserInterceptor
        logger                         log.Logger
    }
    type args struct {
        ctx   context.Context
        input *{{ .ProtoPackage }}.UserGet
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    *{{ .ProtoPackage }}.User
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                userInterceptor.EXPECT().Get(ctx, user.ID, user).Return(user, nil).Times(1)
            },
            fields: fields{
                UnimplementedUserServiceServer: {{ .ProtoPackage }}.UnimplementedUserServiceServer{},
                userInterceptor:                userInterceptor,
                logger:                         logger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.UserGet{
                    Id: user.ID,
                },
            },
            want:    decodeUser(user),
            wantErr: nil,
        },
        {
            name: "interceptor error",
            setup: func() {
                userInterceptor.EXPECT().Get(ctx, user.ID, user).
                    Return(nil, errs.NewUnexpectedBehaviorError("i error")).
                    Times(1)
            },
            fields: fields{
                UnimplementedUserServiceServer: {{ .ProtoPackage }}.UnimplementedUserServiceServer{},
                userInterceptor:                userInterceptor,
                logger:                         logger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.UserGet{
                    Id: user.ID,
                },
            },
            want:    nil,
            wantErr: decodeError(errs.NewUnexpectedBehaviorError("i error")),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            u := UserServiceServer{
                UnimplementedUserServiceServer: tt.fields.UnimplementedUserServiceServer,
                userInterceptor:                tt.fields.userInterceptor,
                logger:                         tt.fields.logger,
            }
            got, err := u.Get(tt.args.ctx, tt.args.input)
            if !errors.Is(err, tt.wantErr) {
                t.Errorf("Get() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("Get() got = %v, want %v", got, tt.want)
            }
        })
    }
}

func TestUserServiceServer_List(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    userInterceptor := mock_interceptors.NewMockUserInterceptor(ctrl)
    logger := mock_log.NewMockLogger(ctrl)
    ctx := context.Background()
    user := mock_models.NewUser(t)
    ctx = context.WithValue(ctx, UserKey, user)
    userFilter := mock_models.NewUserFilter(t)
    count := uint64(faker.RandomInt64(1, 100))
    response := &{{ .ProtoPackage }}.Users{
        Users: make([]*{{ .ProtoPackage }}.User, 0, int(count)),
        Count: count,
    }
    users := make([]*models.User, 0, int(count))
    for i := 0; i < int(count); i++ {
        u := mock_models.NewUser(t)
        users = append(users, u)
        response.Users = append(response.Users, decodeUser(u))
    }
    type fields struct {
        UnimplementedUserServiceServer {{ .ProtoPackage }}.UnimplementedUserServiceServer
        userInterceptor                interceptors.UserInterceptor
        logger                         log.Logger
    }
    type args struct {
        ctx   context.Context
        input *{{ .ProtoPackage }}.UserFilter
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    *{{ .ProtoPackage }}.Users
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                userInterceptor.EXPECT().List(ctx, userFilter, user).Return(users, count, nil).Times(1)
            },
            fields: fields{
                UnimplementedUserServiceServer: {{ .ProtoPackage }}.UnimplementedUserServiceServer{},
                userInterceptor:                userInterceptor,
                logger:                         logger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.UserFilter{
                    PageNumber: wrapperspb.UInt64(*userFilter.PageNumber),
                    PageSize:   wrapperspb.UInt64(*userFilter.PageSize),
                    Search:     wrapperspb.String(*userFilter.Search),
                    OrderBy:    userFilter.OrderBy,
                },
            },
            want:    response,
            wantErr: nil,
        },
        {
            name: "interceptor error",
            setup: func() {
                userInterceptor.EXPECT().List(ctx, &models.UserFilter{}, user).
                    Return(nil, uint64(0), errs.NewUnexpectedBehaviorError("i error")).
                    Times(1)
            },
            fields: fields{
                UnimplementedUserServiceServer: {{ .ProtoPackage }}.UnimplementedUserServiceServer{},
                userInterceptor:                userInterceptor,
                logger:                         logger,
            },
            args: args{
                ctx:   ctx,
                input: &{{ .ProtoPackage }}.UserFilter{},
            },
            want:    nil,
            wantErr: decodeError(errs.NewUnexpectedBehaviorError("i error")),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            u := UserServiceServer{
                UnimplementedUserServiceServer: tt.fields.UnimplementedUserServiceServer,
                userInterceptor:                tt.fields.userInterceptor,
                logger:                         tt.fields.logger,
            }
            got, err := u.List(tt.args.ctx, tt.args.input)
            if !errors.Is(err, tt.wantErr) {
                t.Errorf("List() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("List() got = %v, want %v", got, tt.want)
            }
        })
    }
}

func TestUserServiceServer_Signup(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    userInterceptor := mock_interceptors.NewMockUserInterceptor(ctrl)
    logger := mock_log.NewMockLogger(ctrl)
    ctx := context.Background()
    user := mock_models.NewUser(t)
    ctx = context.WithValue(ctx, UserKey, user)
    create := mock_models.NewUserCreate(t)
    type fields struct {
        UnimplementedUserServiceServer {{ .ProtoPackage }}.UnimplementedUserServiceServer
        userInterceptor                interceptors.UserInterceptor
        logger                         log.Logger
    }
    type args struct {
        ctx   context.Context
        input *{{ .ProtoPackage }}.Signup
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    *{{ .ProtoPackage }}.User
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                userInterceptor.EXPECT().Create(ctx, create, user).Return(user, nil).Times(1)

            },
            fields: fields{
                UnimplementedUserServiceServer: {{ .ProtoPackage }}.UnimplementedUserServiceServer{},
                userInterceptor:                userInterceptor,
                logger:                         logger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.Signup{
                    Email: create.Email,
                    Password: create.Password,
                },
            },
            want:    decodeUser(user),
            wantErr: nil,
        },
        {
            name: "interceptor error",
            setup: func() {
                userInterceptor.EXPECT().Create(ctx, create, user).
                    Return(nil, errs.NewUnexpectedBehaviorError("i error")).
                    Times(1)
            },
            fields: fields{
                UnimplementedUserServiceServer: {{ .ProtoPackage }}.UnimplementedUserServiceServer{},
                userInterceptor:                userInterceptor,
                logger:                         logger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.Signup{
                    Email: create.Email,
                    Password: create.Password,
                },
            },
            want:    nil,
            wantErr: decodeError(errs.NewUnexpectedBehaviorError("i error")),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            u := UserServiceServer{
                UnimplementedUserServiceServer: tt.fields.UnimplementedUserServiceServer,
                userInterceptor:                tt.fields.userInterceptor,
                logger:                         tt.fields.logger,
            }
            got, err := u.Signup(tt.args.ctx, tt.args.input)
            if !errors.Is(err, tt.wantErr) {
                t.Errorf("Signup() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("Signup() got = %v, want %v", got, tt.want)
            }
        })
    }
}

func TestUserServiceServer_Update(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    userInterceptor := mock_interceptors.NewMockUserInterceptor(ctrl)
    logger := mock_log.NewMockLogger(ctrl)
    ctx := context.Background()
    user := mock_models.NewUser(t)
    ctx = context.WithValue(ctx, UserKey, user)
    userUpdate := mock_models.NewUserUpdate(t)
    type fields struct {
        UnimplementedUserServiceServer {{ .ProtoPackage }}.UnimplementedUserServiceServer
        userInterceptor                interceptors.UserInterceptor
        logger                         log.Logger
    }
    type args struct {
        ctx   context.Context
        input *{{ .ProtoPackage }}.UserUpdate
    }
    tests := []struct {
        name    string
        setup   func()
        fields  fields
        args    args
        want    *{{ .ProtoPackage }}.User
        wantErr error
    }{
        {
            name: "ok",
            setup: func() {
                userInterceptor.EXPECT().Update(ctx, &models.UserUpdate{
                    ID:          userUpdate.ID,
                    FirstName:   userUpdate.FirstName,
                    LastName:    userUpdate.LastName,
                    Password:    userUpdate.Password,
                    Email:       userUpdate.Email,
                }, user).Return(user, nil).Times(1)
            },
            fields: fields{
                UnimplementedUserServiceServer: {{ .ProtoPackage }}.UnimplementedUserServiceServer{},
                userInterceptor:                userInterceptor,
                logger:                         logger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.UserUpdate{
                    Id:        userUpdate.ID,
                    FirstName: wrapperspb.String(*userUpdate.FirstName),
                    LastName:  wrapperspb.String(*userUpdate.LastName),
                    Email:     wrapperspb.String(*userUpdate.Email),
                    Password:  wrapperspb.String(*userUpdate.Password),
                },
            },
            want:    decodeUser(user),
            wantErr: nil,
        },
        {
            name: "interceptor error",
            setup: func() {
                userInterceptor.EXPECT().Update(ctx, &models.UserUpdate{
                    ID:          userUpdate.ID,
                    FirstName:   userUpdate.FirstName,
                    LastName:    userUpdate.LastName,
                    Password:    userUpdate.Password,
                    Email:       userUpdate.Email,
                }, user).
                    Return(nil, errs.NewUnexpectedBehaviorError("i error"))
            },
            fields: fields{
                UnimplementedUserServiceServer: {{ .ProtoPackage }}.UnimplementedUserServiceServer{},
                userInterceptor:                userInterceptor,
                logger:                         logger,
            },
            args: args{
                ctx: ctx,
                input: &{{ .ProtoPackage }}.UserUpdate{
                    Id:        userUpdate.ID,
                    FirstName: wrapperspb.String(*userUpdate.FirstName),
                    LastName:  wrapperspb.String(*userUpdate.LastName),
                    Email:     wrapperspb.String(*userUpdate.Email),
                    Password:  wrapperspb.String(*userUpdate.Password),
                },
            },
            want:    nil,
            wantErr: decodeError(errs.NewUnexpectedBehaviorError("i error")),
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            u := UserServiceServer{
                UnimplementedUserServiceServer: tt.fields.UnimplementedUserServiceServer,
                userInterceptor:                tt.fields.userInterceptor,
                logger:                         tt.fields.logger,
            }
            got, err := u.Update(tt.args.ctx, tt.args.input)
            if !errors.Is(err, tt.wantErr) {
                t.Errorf("Update() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("Update() got = %v, want %v", got, tt.want)
            }
        })
    }
}

func Test_decodeUser(t *testing.T) {
    user := mock_models.NewUser(t)
    type args struct {
        user *models.User
    }
    tests := []struct {
        name string
        args args
        want *{{ .ProtoPackage }}.User
    }{
        {
            name: "ok",
            args: args{
                user: user,
            },
            want: &{{ .ProtoPackage }}.User{
                Id:        user.ID,
                FirstName: user.FirstName,
                LastName:  user.LastName,
                Email:     user.Email,
                CreatedAt: timestamppb.New(user.CreatedAt),
            },
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := decodeUser(tt.args.user); !reflect.DeepEqual(got, tt.want) {
                t.Errorf("decodeUser() = %v, want %v", got, tt.want)
            }
        })
    }
}

func Test_encodeUserFilter(t *testing.T) {
    type args struct {
        input *{{ .ProtoPackage }}.UserFilter
    }
    tests := []struct {
        name  string
        setup func()
        args  args
        want  *models.UserFilter
    }{
        {
            name: "ok",
            setup: func() {

            },
            args: args{
                input: &{{ .ProtoPackage }}.UserFilter{
                    PageNumber: &wrapperspb.UInt64Value{
                        Value: 2,
                    },
                    PageSize: &wrapperspb.UInt64Value{
                        Value: 5,
                    },
                    Search: &wrapperspb.StringValue{
                        Value: "my name is",
                    },
                    OrderBy: []string{"created_at", "id"},
                },
            },
            want: &models.UserFilter{
                PageSize:   utils.Pointer(uint64(5)),
                PageNumber: utils.Pointer(uint64(2)),
                Search:     utils.Pointer("my name is"),
                OrderBy:    []string{"created_at", "id"},
            },
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.setup()
            if got := encodeUserFilter(tt.args.input); !reflect.DeepEqual(got, tt.want) {
                t.Errorf("encodeUserFilter() = %v, want %v", got, tt.want)
            }
        })
    }
}
